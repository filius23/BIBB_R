{
  "hash": "920f54692c2431e1138f77bb6d11bbb5",
  "result": {
    "markdown": "# Arbeiten mit Datensätzen in R\n\n\n\n\n\n**(Spätes) Vorwort zu R und der Befehlsstruktur**\n\n\n::: callout-note\n#\n\n1.  Alles ist ein Objekt.\n2.  Alles hat einen Namen.\n3.  Alles was wir tun basiert auf Funktionen.\n4.  Funktionen kommen aus \"packages\"[^pkg], aber wir werden auch eigene Funktionen schreiben.\n\n[^pkg]: In vielen anderen Programmiersprachen ist auch von Bibliotheken/\"libraries\" die Rede.\n\nPunkt 1. und 2. wird als [Objektorientierte Programmierung (object-orientated programming, OOP)](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung) bezeichnet. Wir werden in diesem Kurs also objektorientierte Programmierung lernen.\n:::\n\nKlingt gut, oder?\n\n\n-   Funktionen sind (fast) immer Verben gefolgt von einer Klammer, bspw. `colnames()`, in welcher das zu bearbeitende Objekt angegeben wird. Das kann bspw. eine Variable oder ein Datensatz sein \n-  Außerdem werden in den Klammern auch ggf. Optionen angegeben - bspw. sehen wir unten den Einlesebefehl für .csv-Dateien: `read.csv(datei.csv, header = T, sep = \",\")`\n-  Zeilenumbrüche werden von R ignoriert, d.h. wir können einen Befehl über mehre Zeilen schreiben - bspw. um es etwas übersichtlicher zu halten:\n\n::: {.cell}\n\n```{.r .cell-code}\nfunktion(objektname1,\n         option1 = sehr_lange_Auswahl_die_sehr_lang_ist,\n         option2 = noch_eine_Auswahl_Option2)\n```\n:::\n\n\n-  Wenn wir eine Funktion durchführen mit `funktion(objektname, option1 = TRUE, option2 = FALSE)` bekommen wir das Ergebnis in der Konsole ausgegeben.\n-  Soll das Ergebnis einer Berechnung oder Operation nicht nur angezeigt werden, sondern für weitere Schritte behalten werden, muss mit `name <- ...` das Ergebnis unter `name` abgelegt werden. Das Ausgangsobjekt bleibt unverändert - außer wir überschreiben das Ausgangsobjekt explizit `name <- funktion(name)`. Hier im Skript werde ich sehr häufig den Schritt des Ablegens weglassen, weil wir ja direkt sehen wollen, was passiert. Wenn wir aber mit bisherigen Operationen weiterarbeiten wollen, dann müssen wir sie in R unter einem Objektnamen ablegen.\n- Optionen innerhalb einer `()` können auch einfach auf Basis der Reihenfolge angegeben werden\n- Mit `?funktion()` ist die Hilfe aufrufbar, bspw. `?colnames()`\n\nEin paar allgemeine Aspekte, in denen sich das Arbeiten mit R von dem mit einigen anderen Programmen unterscheidet:\n\n- R stoppt nicht notwendigerweise bei einem Syntaxfehler, sondern versucht den Rest der Befehle auszuführen. *Aber:* RStudio stoppt ab [Version 2022.07](https://stackoverflow.com/questions/73567974/how-to-make-r-by-default-not-stopping-when-an-error-is-encountered-while-running/73641357#73641357) bei einem Syntaxfehler.\n\n- Für alle Stata-Nutzenden: kein `variable xyz already defined` mehr. Wir können alles überschreiben, ohne `, replace` oder ähnliches.\n\n- Durch die Objektorientierung haben wir die Möglichkeit mehrere Datensätze gleichzeitig geöffnet zu haben - das erhöht die Flexibilität.\n\nIn der ersten Session haben wir einige Schritte mit der Taschenrechnerfunktion in R unternommen. Die wirkliche Stärke von R ist aber die Verarbeitung von Daten - los geht's.\n\n\n## Datenstrukturen in R: `data.frame`\n\nIm vorherigen Kapitel haben wir die Studierendenzahlen der Uni Bremen (19173), Uni Vechta (5333) und Uni Oldenburg (15643) zusammen unter `studs` abgelegt und mit den in `profs` abgelegten Professurenzahlen ins Verhältnis gesetzt. Das funktioniert soweit gut, allerdings ist es übersichtlicher, zusammengehörige Werte auch zusammen ablegen. Dafür gibt es in R `data.frame`. Wir können dazu die beiden Objekte in einem Datensatz ablegen, indem wir sie in `data.frame` eintragen und das neue Objekt unter `dat1` ablegen. Wenn wir `dat1` aufrufen sehen wir, dass die Werte zeilenweise zusammengefügt wurden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstuds <- c(19173,5333,15643)    # Studierendenzahlen unter \"studs\" ablegen \nprofs       <- c(322,67,210)    # Prof-Zahlen unter \"profs\" ablegen\ndat1_orig <- data.frame(studs, profs)\ndat1_orig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 <- data.frame(studs = c(19173,5333,15643), \n                   profs = c(322,67,210),\n                   gegr  = c(1971,1830,1973)) # ohne zwischen-Objekte\ndat1    # zeigt den kompletten Datensatz an\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n```\n:::\n:::\n\n\nIn der ersten Zeile stehen also die Werte der Uni Bremen, in der zweiten Zeile die Werte der Uni Vechta usw. Die Werte können wir dann mit `datensatzname$variablenname` aufrufen. So können wir die Spalte `profs` anzeigen lassen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$profs \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 322  67 210\n```\n:::\n:::\n\n\nMit `colnames()`/`names()` können wir die Variablen-/Spaltennamen des Datensatzes anzeigen lassen, zudem können wir mit `nrow` und `ncol` die Zahl der Zeilen bzw. Spalten aufrufen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(dat1) ## Variablen-/Spaltennamen anzeigen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"studs\" \"profs\" \"gegr\" \n```\n:::\n\n```{.r .cell-code}\nnames(dat1) ## Variablen-/Spaltennamen anzeigen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"studs\" \"profs\" \"gegr\" \n```\n:::\n\n```{.r .cell-code}\nncol(dat1) ## Anzahl der Spalten/Variablen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnrow(dat1) ## Anzahl der Zeilen/Fälle\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nNeue zusätzliche Variablen können durch `datensatzname$neuevariable` in den Datensatz eingefügt werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$stu_prof <- dat1$studs/dat1$profs\n## dat1 hat also nun eine Spalte mehr:\nncol(dat1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof\n1 19173   322 1971 59.54348\n2  5333    67 1830 79.59701\n3 15643   210 1973 74.49048\n```\n:::\n:::\n\n\nWir können auch ein oder mehrere Wörter in einer Variable ablegen, jedoch müssen Buchstaben/Wörter immer in `\"\"` gesetzt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$uni <- c(\"Uni Bremen\",\"Uni Vechta\", \"Uni Oldenburg\")\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nMit `View(dat1)` öffnet sich zudem ein neues Fenster, in dem wir den gesamten Datensatz ansehen können:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(dat1)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_View.png){fig-align='center' width=45% height=35%}\n:::\n:::\n\n\n## Variablentypen\n\nDamit haben wir bisher zwei Variablentypen kennen gelernt: numeric (enthält Zahlen) und character (enthält Text oder Zahlen, die als Text verstanden werden sollen). Darüber hinaus gibt es noch weitere Typen, die besprechen wir wenn sie nötig sind, zB. gibt es factor-Variablen, die eine vorgegebene Sortierung und Werteuniversum umfassen oder logische Variablen. Vorerst fokussieren wir uns auf character und numeric Variablen. Mit `class()` kann die Art der Variable untersucht werden oder mit `is.numeric()` bzw. `is.character()` können wir abfragen ob eine Variable diesem Typ entspricht:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(dat1$uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nis.numeric(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.character(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nMit `as.character()` bzw. `as.numeric()` können wir einen Typenwechsel erzwingen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(dat1$profs) ## die \"\" zeigen an, dass die Variable als character definiert ist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"322\" \"67\"  \"210\"\n```\n:::\n:::\n\n\nDas ändert erstmal nichts an der Ausgangsvariable `dat1$profs`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nWenn wir diese Umwandlung für `dat1$profs` behalten wollen, dann müssen wir die Variable überschreiben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$profs <- as.character(dat1$profs)\ndat1$profs \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"322\" \"67\"  \"210\"\n```\n:::\n\n```{.r .cell-code}\nclass(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nMit `character`-Variablen kann nicht gerechnet werden, auch wenn sie Zahlen enthalten:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$profs / 2 \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dat1$profs/2: nicht-numerisches Argument für binären Operator\n```\n:::\n:::\n\n\nWir können aber natürlich `dat1$profs` spontan mit `as.numeric` umwandeln, um mit den Zahlenwerten zu rechnen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 322  67 210\n```\n:::\n\n```{.r .cell-code}\nas.numeric(dat1$profs) / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 161.0  33.5 105.0\n```\n:::\n:::\n\n\nWenn wir Textvariablen in numerische Variablen umwandeln, bekommen wir `NA`s ausgegeben. `NA` steht in R für fehlende Werte:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(dat1$uni)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs durch Umwandlung erzeugt\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n:::\n\n\nR weiß (verständlicherweise) also nicht, wie die Uni-Namen in Zahlen umgewandelt werden sollen.\n\n::: callout-tip\nNicht selten ist ein Problem bei einer Berechnung auf den falschen Variablentypen zurückzuführen.\n:::\n\n\n\n### [Übung](#data1) {#ue_1}\n\n\n## Pakete in R {#packages}\n\nIm nächsten Schritt möchten wir jetzt nur einige Zeilen (Fälle) und/oder Spalten (Variablen) auswählen. \nDazu verwenden wir das Paket `{dplyr}`[^04_intro-1]. \n\n[^04_intro-1]: Es hat sich in der R-Community etabliert, Pakete mit `{}` zu schreiben um sie deutlicher von Funktionen zu unterscheiden. Ich folge in diesem Skript dieser Konvention. \n\nPakete sind Erweiterungen für R, die zusätzliche Funktionen beinhalten. <!-- Wir haben in diesem Kapitel schon einige Beispiele kennen gelernt: mit `{dplyr}` steht uns ein komfortablerer [`filter()`](#filter) zur Verfügung und Stata- oder SPSS-Dateien können wir mit Hilfe des Pakets `haven` einlesen und erstellen.  --> Pakete müssen einmalig installiert werden und dann vor der Verwendung in einer neuen Session (also nach jedem Neustart von R/RStudio) geladen werden. `install.packages()` leistet die Installation, mit `library()` werden die Pakete geladen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"Paket\") # auf eurem PC nur einmal nötig\nlibrary(Paket) # nach jedem Neustart nötig\n```\n:::\n\n\nHäufig werden bei `install.packages()` nicht nur das angegebene Paket, sondern auch eine Reihe weiterer Pakete heruntergeladen, die sog. \"dependencies\". Das sind Pakete, welche im Hintergrund verwendet werden, um die Funktionen des eigentlich gewünschten Pakets zu ermöglichen. Also nicht erschrecken, wenn die Installation etwas umfangreicher ausfällt.\n\nMit `install.packages()` schrauben wir sozusagen die Glühbirne in R, mit `library()` betätigen wir den Lichtschalter, sodass wir die Befehle aus dem Paket auch verwenden können. Mit jedem Neustart geht die Glühbirne wieder aus und wir müssen sie mit `library()` wieder aktivieren. Das hat aber den Vorteil, dass wir nicht alle Glühbirnen auf einmal anknipsen müssen, wenn wir R starten.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/104_install-packages.jpg){fig-align='center' width=53% height=53%}\n:::\n:::\n\n\n:::{.callout-caution}\n# `install.packages()` im BIBB-Netzwerk\n\n\nAufgrund der VPN-Einstellungen im BIBB muss in R folgende Option gesetzt werden, damit Downloads möglich sind:  \n\n`options(download.file.method = \"wininet\")`  \n\nDazu bieten sich zwei Möglichkeiten:\n\n1. nach jedem Neustart von RStudio vor `install.packages()` mit setzen:\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(download.file.method = \"wininet\")\ninstall.packages()\n```\n:::\n\n \n2. diese Option permanent \"verankern\": wer den Befehl nicht zu Beginn jeden R-Scripts aufführen möchte, kann ihn in die `Rprofile`-Datei (`Rprofile.site`) mit globalen Einstellungen aufnehmen. Diese Datei liegt beim BIBB Arbeitsgerät unter folgendem Pfad: `C:\\RforWindows_4_2_1\\etc`\n  [**Mehr zu RProfile**](https://support.posit.co/hc/en-us/articles/360047157094-Managing-R-with-Rprofile-Renviron-Rprofile-site-Renviron-site-rsession-conf-and-repos-conf)\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n# Pakete einmalig laden {#pkgdoublecolon}\n\nNeben `library()` gibt es auch die Möglichkeit, Funktionen aus Paketen mit `::` aufzurufen:\n\n::: {.cell}\n\n```{.r .cell-code}\npaket::function()\n```\n:::\n\n\nDiese Option wird häufig verwendet, wenn lediglich eine Funktion aus einem Paket einmalig verwendet wird und oder um deutlich zu machen, aus welchem Paket die verwendete Funktion kommt. Das kann auch bei Problemen mit einem Befehl hilfreich sein: evtl. wurde ein weiteres Paket mit einem gleichnamigen Befehl geladen - dann wird der erste Befehl überschrieben (meist mit einer Warnung), die bespielweise so aussehen kann:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDie folgenden Objekte sind maskiert von ‘package:dplyr’:\n\n    between, first, last\n\nDas folgende Objekt ist maskiert ‘package:purrr’:\n\n    transpose\n```\n:::\n\n\nDas kann umgangen werden, wenn gewisse Pakte gar nicht vollständig geladen, sondern lediglich die nötigen Funktionen mit `::` aufgerufen werden.\n\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# Wenn keine Internetverbindung besteht\n\nUnter [R Packages](https://cran.r-project.org/web/packages/available_packages_by_name.html) können die benötigten Pakete heruntergeladen werden. Nachdem wir das Paket als .zip-Datei gespeichert haben, wir mit folgendem Befehl das Paket in der R-Umgebung installieren:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Installation von Paket \"XML\"\ninstall.packages(\"E:/XML_3.98-1.3.zip\", repos = NULL, type = \"source\")\n```\n:::\n\n\n:::\n\n\n## `{tidyverse}`\n\nWir werden in diesem Kurs vor allem mit Paketen aus dem [`{tidyverse}`](www.tidyverse.org/) arbeiten. tidyverse ist eine Sammlung an Paketen, die übergreifende Syntaxlogik haben und so besonders gut miteinander harmonisieren und eine riesige Bandbreite an Anwendungsfällen abdecken. Mit\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\nwerden folgende Pakete installiert:\n\nbroom, conflicted, cli, dbplyr, dplyr, dtplyr, forcats, ggplot2, googledrive, googlesheets4, haven, hms, httr, jsonlite, lubridate, magrittr, modelr, pillar, purrr, ragg, readr, readxl, reprex, rlang, rstudioapi, rvest, stringr, tibble, tidyr, xml2, tidyverse\n\nWir werden einige im Laufe des Kurses kennen lernen. Das zunächst wichtigste ist `{dplyr}`, welches unter anderem die Auswahl von Fällen und Variablen erleichtert:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung basierend auf dem [`{dplyr}` Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdat1)](./pic/103_dplyr.png){fig-align='center' width=80% height=80%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\") \n# installiert die komplette Paketsammlung des tidyverse\n```\n:::\n\n\n## Zeilen auswählen mit `slice()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # nach einmaligem install.packages(\"tidyverse\")\n```\n:::\n\n\nEine erste Funktion aus dem `{tidyverse}` ist `slice()`, mit welcher wir Zeilen auswählen können:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(dat1,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof        uni\n1 19173   322 1971 59.54348 Uni Bremen\n```\n:::\n\n```{.r .cell-code}\n2:3 # ergibt eine Zahlenfolge\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nslice(dat1,2:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1  5333    67 1830 79.59701    Uni Vechta\n2 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\nc(1,3) # Vektor mit Werten\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\nslice(dat1,c(1,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\n\n## Beobachtungen auswählen mit `filter()` {#filter}\n\nNachdem wir zunächst das Paket für `filter()` installiert haben (das ist `{dplyr}`) müssen wir das Paket noch mit `library()` laden:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1,uni == \"Uni Oldenburg\", studs > 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nDie Auswahl ändert das Ausgangsobjekt `dat1` aber nicht:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nMöchten wir das Ergebnis unserer Auswahl mit `filter()` für weitere Schritte behalten, können wir unser Ergebnis in einem neuen `data.frame`-Objekt ablegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nueber_10tsd <- filter(dat1, studs > 10000)\nueber_10tsd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\nclass(ueber_10tsd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\n### Auswahloperatoren\n\nR und `{dplyr}` stellen uns einige weitere Operatoren zur Auswahl von Zeilen zu Verfügung:\n\n-   `<=` und `>=`\n-   `|` oder\n-   `%in%` \"eines von\"\n-   `between()` ist eine Hilfsfunktion aus `{dplyr}` für Wertebereiche\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1, studs >= 10000)\nfilter(dat1, studs <= 10000)\nfilter(dat1,studs > 10000 | profs < 200) # mehr als 10.000 Studierende *oder* weniger als 200 Professuren\nfilter(dat1, gegr %in% c(1971,1830)) # gegründet 1971 oder 1830\nfilter(dat1, between(gegr,1971,1830)) # gegründet zwischen 1971 und 1830 (einschließlich)\n```\n:::\n\n\n<!-- Erweiterte Hilfsfunktionen für `filter()`:  `if_any()` or `if_all()` -->\n\n<!-- ```{r, eval =F } -->\n<!-- etb18 %>% filter(if_any(matches(\"^F\"), ~ .x < 10)) -->\n<!-- ``` -->\n\n\n\n## Variablentypen II: logical\n\nDiese Auswahl basiert auf einem dritten Variablentyp: 'logical', also logische Werte mit `TRUE` oder `FALSE`. Wenn wir mit `==`, `>` oder `<` eine Bedingung formulieren, dann erstellen wir eigentlich einen logischen Vektor in der selben Länge wie die Daten:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$studs > 10000 # ist die Studi-Zahl größer 10000?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\ndat1$more10k <-  dat1$studs > 10000 # ist die Studi-Zahl größer 10000?\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2  5333    67 1830 79.59701    Uni Vechta   FALSE\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n```\n:::\n:::\n\n\nWir könnten dann auch auf Basis dieser Variable filtern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1,more10k)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n```\n:::\n:::\n\n\n## Variablen auswählen mit `select()` {#select}\n\nMit `select()` enthält `{dplyr}` auch einen Befehl zu Auswahl von Spalten/Variablen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2  5333    67 1830 79.59701    Uni Vechta   FALSE\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n```\n:::\n\n```{.r .cell-code}\nselect(dat1, studs,profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\n```\n:::\n:::\n\n\nWir können auch hier einige Operatoren verwenden: `:` um einen Bereich auszuwählen oder `!` als \"nicht\"-Operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(dat1, 1:3) # Spalte 1-3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n```\n:::\n\n```{.r .cell-code}\nselect(dat1, !profs) # alles außer profs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs gegr stu_prof           uni more10k\n1 19173 1971 59.54348    Uni Bremen    TRUE\n2  5333 1830 79.59701    Uni Vechta   FALSE\n3 15643 1973 74.49048 Uni Oldenburg    TRUE\n```\n:::\n:::\n\n\nAuch hier gilt: wenn wir die Veränderungen auch weiter verwenden wollen, müssen wir sie in einem neuen Objekt ablegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_ohne_profs <- select(dat1, !profs) \ndat_ohne_profs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs gegr stu_prof           uni more10k\n1 19173 1971 59.54348    Uni Bremen    TRUE\n2  5333 1830 79.59701    Uni Vechta   FALSE\n3 15643 1973 74.49048 Uni Oldenburg    TRUE\n```\n:::\n:::\n\n\n...oder das alte überschreiben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 <- select(dat1, !profs) # alles außer profs\n```\n:::\n\n\n### Hilfsfunktionen {#selecthelpers}\n\n`select()` hat außerdem einige Hilfsfunktionen, welche die Variablenauswahl auf Basis der Variablennamen einfacher machen.\n\n-   `starts_with()`: Variablenname beginnt mit ..., bspw. `select(dat1,starts_with(\"p\"))`\n-   `ends_with()`: Variablenname endet mit ..., bspw. `select(dat1,ends_with(\"p\"))`\n-   `matches()`: Variablenauswahl mit einer [*regular expression*](https://jfjelstul.github.io/regular-expressions-tutorial/), bspw. `select(dat1,matches(\"_\"))`: alle Variablen mit `_` im Namen.\n-   `num_range()`: Variablen mit Zahlenbereiche: `select(etb,num_range(\"F\",1:220))`\n-   `last_col()`: Letzte Variable, für die 4.letzte Variable bspw. `last_col(4)`\n-   `any_of()` um eine Auswahl auf Basis eines `character`-Vektors zu treffen\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Spalten eines `data.frame`s auf Basis der `colnames` eines data.frames auswählen möchten:\ncol_auswahl <- colnames(dat1_orig)\ncol_auswahl\nselect(dat1, any_of(col_auswahl) )\n\n\n# Oder wir wollen alle Variablen, die mit \"s\" beginnen:\nselect(dat1,starts_with(\"s\"))\nselect(dat1,matches(\"^s\")) # gleiches Ergebnis mit regex\nselect(dat1,matches(\"s$\")) # alle Spalten, die mit s enden\n```\n:::\n\n\n\nEs gibt noch einige weitere Hilfsfunktionen, für eine vollständige Auflistung `?select_helpers`.\n\n### [Übung](#data2) {#ue_2}\n\n## Arbeiten mit der Pipe: `filter()` und `select()` kombinieren  {#pipe}\n\n\nWenn wir jetzt aber einige Zeilen **und** einige Spalten auswählen möchten, dann können wir `filter()` und `select()` kombinieren:\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(filter(dat1,studs < 10000),uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\nDiese Befehlsschachtel können wir mit der sog. Pipe `%>%` auflösen. `%>%` steht einfach für \"und dann\". Die Pipe kommt aus dem Paket `{magrittr}`, welches wiederum Teil des tidyverse ist und automatisch mit `{dplyr}` geladen wird. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1,studs < 10000) %>% select(uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\n\nHäufig wird die Pipe dann so verwendet, dass zu Beginn lediglich der zu bearbeitende Datensatz steht und sich dann die Schritte anschließen:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% filter(.,studs < 10000) %>% select(.,uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\n\n\nDer Punkt `.` steht jeweils für das Ergebnis des vorherigen Schritts. Hier also:\n\n   1. Rufe `dat1` auf *und dann (`%>%`)*\n   2. Wähle nur Zeilen aus in denen `studs` < 10000 *und dann (`%>%`)*\n   3. Behalte nur die Spalte `uni`\n\nDan Punkt können wir auch weglassen:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% filter(studs < 10000) %>% select(uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\n\n\n:::{.callout-tip}\n\n`%>%` kann mit STRG+SHIFT+m (cmd+shift+m für Mac) eingefügt werden.\n\n:::\n\n\n\n\n## Variablentyp III: `factor` - eigene Reihenfolgen festlegen\n\n\nEin weitere häufige Aufgabe in der Datenanalyse ist das Sortieren von Datensätzen. Dazu haben wir `arrange()` zur Verfügung:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k\n1  5333    67 1830 79.59701    Uni Vechta   FALSE\n2 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n3 19173   322 1971 59.54348    Uni Bremen    TRUE\n```\n:::\n:::\n\n\nDas funktioniert auch für `string`-Variablen:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n3  5333    67 1830 79.59701    Uni Vechta   FALSE\n```\n:::\n:::\n\n\nWas aber, wenn wir eine fixe Ordnung vergeben möchten, die nicht der numerischen oder alphabetischen Ordnung entspricht?\nHier bspw. wenn wir die Unis in folgende Ordnung bringen möchten: 1) Uni Oldenburg, 2) Uni Bremen und 3) Uni Vechta.\nDabei hilft uns ein dritter Variablentyp: `factor`. \n\nMit dem Argument `levels =` können wir eine Reihenfolge festlegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(dat1$uni, levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Uni Bremen    Uni Vechta    Uni Oldenburg\nLevels: Uni Oldenburg Uni Bremen Uni Vechta\n```\n:::\n\n```{.r .cell-code}\ndat1$uni_fct <- factor(dat1$uni, \n                       levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n```\n:::\n\n\nWenn wir nun nach `uni_fct` sortieren, dann wird die Reihenfolge der `levels` berücksichtigt:\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dat1$uni_fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\ndat1 %>% arrange(uni_fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n2 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n3  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n```\n:::\n:::\n\n\nMit `desc()` können wir in umgekehrter Reihenfolge sortieren:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(desc(uni_fct))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n```\n:::\n:::\n\n\nDas mag für den Moment relativ trivial erscheinen, ist aber später sehr praktisch um in Grafiken Variablen in eine gewisse Ordnung zu bringen oder in Regressionsmodellen die Referenzkategorie festzulegen.\n\nNatürlich können wir auch nach mehreren Variablen sortieren, dazu fügen wir einfach weitere in `arrange()` ein:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(desc(uni_fct), gegr, studs) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n```\n:::\n:::\n\n(Macht in diesem Beispiel aber wenig Sinn)\n\n### [Übung](#data3) {#ue_3}\n\n## Datensätze einlesen {#import}\n\nIn der Regel werden wir aber Datensätze verwenden, deren Werte bereits in einer Datei gespeichert sind und die wir lediglich einlesen müssen. Dafür gibt es unzählige Möglichkeiten.\n\nWir werden hier vor allem den Import von csv-Dateien verwenden. csv [^02_intro-1] bezeichnet ein verbreitetes Dateiformat zur Speicherung oder zum Austausch einfach strukturierter Daten. Wesentlich für unsere Zwecke hier ist, dass in csv-Dateien die Spalten eines Datensatzes mit einem Trennzeichen gekennzeichnet sind. Verbreitete Trennzeichen sind Komma, Doppelpunkt oder Semikolon. Für alle weiteren Dateien, die wir im Lauf dieser Veranstaltung verwenden werden, ist das Semikolon als Trennzeichen gesetzt. Unser Datensatz `dat1` sieht im csv-Format so aus:\n\n[^02_intro-1]: Abkürzung für comma-separated values\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n![](./pic/102_csvdatei.png)\n\nIn diesem Seminar werden wir mit Daten aus BIBB/BAuA-Erwerbstätigenbefragung 2018 arbeiten. Die BIBB/BAuA ist eine Repräsentativbefragung von in Deutschland zu Arbeit und Beruf im Wandel und Erwerb und Verwertung beruflicher Qualifikation. Nun wollen wir also eine csv-Datei einlesen, zunächst eine reduzierte Version der ETB 2018.\n\nUm den Datensatz nun in R zu importieren, müssen wir R mitteilen unter welchem Dateipfad der Datensatz zu finden ist. Der Dateipfad ergibt sich aus der Ordnerstruktur Ihres Gerätes, so würde der Dateipfad im hier dargestellten Fall \"D:/Kurse/R-Kurs/\" lauten:\n\nNatürlich hängt der Dateipfad aber ganz davon ab, wo Sie den Datensatz gespeichert haben:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_dateipfad_datei.png){fig-align='center' width=45% height=45%}\n:::\n:::\n\n\nUm den Pfad des Ordners herauszufinden, klicken Sie bei Windows in die obere Adresszeile im Explorerfenster.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/101_Dateipfad_WIN.png){fig-align='center' width=40% height=40%}\n:::\n:::\n\n\n::: note\nIn iOS (Mac) finden Sie den Pfad, indem Sie einmal mit der rechten Maustaste auf die Datei klicken und dann die ALT-Taste gedrückt halten. Dann sollte die Option \"...als Pfadname kopieren\" erscheinen. [**Youtube Anleitung**](https://www.youtube.com/watch?v=zcb3D6Xdv4s)\n:::\n\nDiesen Dateipfad müssen wir also R mitteilen.\n\n### Projekt einrichten {#rproj}\n\nGrundsätzlich lohnt es sich, in RStudio Projekte einzurichten. \nProjekte sind `.Rproj`-Dateien ![](./pic/rproj-icon.png){width=\"30px\"}, die automatisch Arbeitsverzeichnis auf den Ort setzen, an dem sie gespeichert sind. \nDas erleichtert das kollaborative Arbeiten: egal wer und auf welchem Gerät gerade an einem Projekt arbeitet - durch die Projektdatei sind alle Pfade immer relativ zum Projektverzeichnis. Im weiteren können auch Versionkontrolle via git, bspw. [github](www.github.com) und weitere Funktionen in der Projektdatei hinterlegt werden und so für alle Nutzenden gleich gesetzt werden. \nAußerdem bleiben die zuletzt geöffneten Scripte geöffnet, was ein Arbeiten an mehreren Projekten erleichtert.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_Rproj.png){fig-align='center' width=65% height=55%}\n:::\n:::\n\n\nMit `getwd()` lässt sich überprüfen, ob das funktioniert hat:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"D:/Kurse/R-Kurs\"\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_Rproj2.png){fig-align='center' width=75% height=70%}\n:::\n:::\n\n\nAlternativ könnten wir auch mit folgendem Befehl ein .Rproj - Projekt erstellen (hier ein Beispiel für den [Aufruf eines Pakets mit `::`](#packages)):\n\n::: {.cell}\n\n```{.r .cell-code}\nrstudioapi::initializeProject(path = \"D:/Kurse/R-Kurs\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n### Der Einlesebefehl\n\nJetzt können wir den eigentlichen Einlesebefehl `read.table` verwenden. Für den Pfad können wir nach `file =` lediglich die Anführungszeichen angeben und innerhalb dieser die Tab-Taste drücken. Dann bekommen wir alle Unterverzeichnisse und Tabellen im Projektordner angezeigt.[^2]\n\n[^2]: Manchmal kann der Datensatz aber nicht im Unterordner des Projekts liegen, dann kann natürlich auch der gesamte Pfad in `read.table()` angegeben werden: `etb <- read.table(file = \"D:/Kurse/R-Kurs/data/BIBBBAuA_2018_small.csv\", sep = \";\", header = T)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\netb <- read.table(file = \"./data/BIBBBAuA_2018_small.csv\", sep = \";\", header = T)\n```\n:::\n\n\nDer Einlesevorgang besteht aus zwei Teilen: zuerst geben wir mit `etb` den Objektnamen an, unter dem R den Datensatz ablegt. Nach dem `<-` steht dann der eigentliche Befehl `read.table()`, der wiederum mehrere Optionen enthält. Als erstes geben wir den genauen Datensatznamen an - inklusive der Dateiendung. Darüber hinaus teilen wir R mit `sep` mit, dass ; als Trennzeichen gesetzt wurde und mit `header = T` (`T` steht für `TRUE`) teilen wir R zudem mit, dass die erste Zeile aus dem Datensatz als Spaltennamen verwendet werden soll.\n\n::: important\nLeider nutzen Windows-Systeme `\\` in den Dateipfaden - das führt in R zu Problemen. Daher müssen Dateipfade immer mit `/` oder alternativ mit `\\\\` angegeben werden. RStudio kann zumindest etwas unterstützen, dem mit der *STRG + F* die Suchen & Ersetzen Funktion verwendet wird.\n:::\n\nWürden hier jetzt einfach `etb` eintippen bekämen wir den kompletten Datensatz angezeigt. Für einen Überblick können wir `head` verwenden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(etb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  intnr az S1 S3 S2_j zpalter Stib Bula m1202 F209 F209_01\n1   260 80  1  8 1976      41    4   11     4    1      NA\n2   361 30  2  5 1966      51    2   11     2    1      NA\n3   491 40  1  7 1968      49    1   11     4    2       1\n4   690 40  2  8 1954      63    3   11     4    1      NA\n5   919 39  2  7 1976      41    2   11     2    1      NA\n6  1041 40  1  5 1960      57    2   11     2    2       2\n```\n:::\n:::\n\n\nMit `nrow` und `ncol` können wir kontrollieren, ob das geklappt hat. Der Datensatz sollte 20012 Zeilen und 11 Spalten haben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(etb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20012\n```\n:::\n\n```{.r .cell-code}\nncol(etb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\nNatürlich können wir wie oben auch aus diesem, viel größeren, Datensatz Zeilen und Spalten auswählen. Zum Beispiel können wir die Befragten auswählen, die vor 1940 geboren sind und diese unter `senior` ablegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsenior <- etb %>% filter(S2_j < 1940)\n```\n:::\n\n\nMöchten wir die genauen Altersangaben der Befragten aus `senior` sehen, können wir die entsprechende Spalte mit `senior$age` aufrufen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsenior$zpalter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 78 83 78 81 81 78 81 80 82 81 79 79 81 78 87\n```\n:::\n:::\n\n\nAußerdem hat `senior` natürlich deutlich weniger Zeilen als `etb`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(senior)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\nWie wir beim Überblick gesehen haben, gibt es aber noch deutlich mehr Variablen in der ETB als `zpalter` und nicht alle haben so aussagekräftige Namen - z.B. `gkpol`. Um diese Variablennamen und auch die Bedeutung der Ausprägungen zu verstehen brauchen wir das Codebuch.\nAußerdem können wir auf die `attributes()` einer Variable zurückgreifen - mehr zu labels später.\n\n\n### [Übung](#data4) {#ue_4}\n\n## Überblick: Einlesen und Exportieren\n\n### Datensätze einlesen\n\n::: panel-tabset\n\n## Überblick\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-material table table-striped table-hover table-condensed\" style=\"font-family: Roboto; margin-left: auto; margin-right: auto; font-size: 12px; width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Dateityp </th>\n   <th style=\"text-align:left;\"> R Funktion </th>\n   <th style=\"text-align:left;\"> R Paket </th>\n   <th style=\"text-align:left;\"> Anmerkung </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> .csv </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read.table() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> mit `sep = \";\"` Trennzeichen angeben </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .Rdata (R format) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> readRDS </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> große .csv </td>\n   <td style=\"text-align:left;font-family: monospace;\"> vroom() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {vroom} </td>\n   <td style=\"text-align:left;\"> mit `delim = \";\"` Trennzeichen angeben </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dta (Stata) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read_dta() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dat (SPSS) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read_spss() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .xlsx (Excel) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read_xlsx() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {readxl} </td>\n   <td style=\"text-align:left;\"> mit `sheet = 1` Tabellenblatt angeben (funktioniert auch mit Namen) </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Code\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# csv Datei\ndat1 <- read.table(file = \"Dateiname.csv\",sep = \";\")\n# Rdata\ndat1 <- readRDS(file = \"Dateiname.Rdata\")\n# große csv\nlibrary(vroom)\ndat1 <- vroom(file = \"Dateiname.csv\",delim = \";\")\n# Stata dta\nlibrary(haven)\ndat1 <- read_dta(file = \"Dateiname.dta\")\n# SPSS sav\ndat1 <- read_sav(file = \"Dateiname.sav\")\n# Excel\ndat1 <- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"1\")\ndat1 <- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"Tabellenblatt1\")\n```\n:::\n\n:::\n\n### Datensätze exportieren\n\n::: panel-tabset\n## Überblick\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-material table table-striped table-hover table-condensed\" style=\"font-family: Roboto; margin-left: auto; margin-right: auto; font-size: 12px; width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Dateityp </th>\n   <th style=\"text-align:left;\"> R Funktion </th>\n   <th style=\"text-align:left;\"> R Paket </th>\n   <th style=\"text-align:left;\"> Anmerkung </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> .Rdata (R format) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> saveRDS() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> alle Variableneigenschaften bleiben erhalten </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .csv </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write.table() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> mit `sep = \";\"` Trennzeichen angeben<br>mit row.names= F Zeilennummerierung unterdrücken </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dta (Stata) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write_dta() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dat (SPSS) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write_spss() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .xlsx (Excel) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write.xlsx() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {xlsx} </td>\n   <td style=\"text-align:left;\"> mit `sheetName` ggf. Tabellenblattname angeben </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rdata\nsaveRDS(dat1,file = \"Dateiname.Rdata\")\n# csv\nwrite.table(dat1,file = \"Dateiname.csv\",sep = \";\",row.names = F)\n# dta\nlibrary(haven)\nwrite_dta(dat1,path = \"Dateiname.dta\")\n# sav\nlibrary(haven)\nwrite_sav(dat1,path = \"Dateiname.sav\")\n# xlsx\nlibrary(xlsx)\nwrite.xlsx(dat1,file = \"Dateiname.xlsx\", sheetName = \"Tabellenblatt 1\")\n```\n:::\n\n:::\n\n### Objekte exportieren\n\nWir können aber auch einzelne oder mehrere Objekte exportieren und später wieder einlesen:\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(studs, file = \"./data/stud_vektor.RData\")\nrm(studs)\nload(file = \"./data/stud_vektor.RData\") # studs wieder mit selbem Namen zurück im environment\n```\n:::\n\n\nMehrere Objekte:\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(studs,profs, file = \"./data/meine_vektoren.RData\")\nrm(studs,profs)\nload(file = \"./data/meine_vektoren.RData\") # studs & profs mit selbem Namen zurück im environment\n```\n:::\n\n\n::: callout-note\n#\n\nDer Begriff *speichern* kann in R bisweilen zu Missverständnissen führen: Ist gemeint, einen Datensatz o.ä. (1) auf der Festplatte als .csv, .dta, .sav für andere Programme zugänglich abzulegen oder lediglich die Ergebnisse intern in R unter einem Objektnamen abzulegen? Ich vermeide daher das Wort speichern und spreche entweder von exportieren (im Fall 1 - in eine Datei schreiben) oder ablegen (Fall 2 - Ergebnisse/Werte innerhalb von R in einem Objekt abzulegen)\n:::\n\n\n## Hilfe zu Paketen und Funktionen\n\nR Pakete kommen (häufig) mit sehr ausführlichen Hilfeseiten, die entweder direkt aus RStudio abgerufen werden können:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Hilfe zu Paketen\nvignette(\"dplyr\")\nvignette(package = \"dplyr\")\nvignette(\"rowwise\")\nhelp(\"dplyr\")\nhelp(package = \"dplyr\")\n\n\n# Hilfe zu Funktionen\n?select()\n```\n:::\n\n\nAlternativ führt aber Google auch zum Ziel, bspw. [**R dplyr select()**](https://www.google.de/search?q=R+dplyr+select())\n\nOder auf CRAN (woher auch `install.packages()` die Pakete bezieht):\n\n::: {.cell}\n::: {.cell-output-display}\n![[CRAN-Seite für {dplyr}](https://cran.r-project.org/web/packages/dplyr/index.html)](./pic/102_dplyr_vignette.png){width=488 height=30%}\n:::\n:::\n\n\n\n## Übungen\n### Übung 1 {#data1}\n\n-   Erstellen Sie den Datensatz mit den Studierenden- & Prof-Zahlen wie gezeigt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- data.frame(studs = c(14954,47269 ,23659,9415 ,38079), \n                   profs = c(250,553,438 ,150,636),\n                   prom_recht = c(FALSE,TRUE,TRUE,TRUE,FALSE),\n                   gegr  = c(1971,1870,1457,1818,1995))\n```\n:::\n\n\n\n\n-   Sehen Sie den `dat2` in Ihrem Environment?\n-   Lassen Sie sich `dat2` in der Console ausgeben.\n-   Fügen Sie die Namen der Unis als neue Spalte in den Datensatz ein. Diese sind in dieser Reihenfolge:\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"FH Aachen\",\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Bonn-Rhein-Sieg\")\n```\n:::\n\n\n-  Lassen Sie sich `dat2` anzeigen - in der Console oder mit `View()`\n-  Berechnen Sie das Verhältnis Studierende pro Professur und legen Sie die Ergebnisse in einer neuen Variable an. Sehen Sie sich das Ergebnis an.\n\n[Zurück nach oben](#ue_1)\n\n### Übung 2 {#data2}\n\n-   ~~Installieren Sie die Pakete des tidyverse mit `install.packages(\"tidyverse\")`~~\n-   Verwenden Sie wieder den `data.frame` `dat2` aus Übung 1\n-   Nutzen Sie `filter`, um sich nur die Unis mit unter 10000 Studierenden anzeigen zu lassen. (Denken Sie daran, `{tidyverse}` zu installieren und mit `library()` zu laden)\n-   Lassen Sie sich nur die dritte Zeile von `dat2` anzeigen.\n-   Lassen Sie sich nur die Spalte `gegr` anzeigen.\n-   Lassen Sie sich nur Zeilen der Hochschulen mit Promotionsrecht (`prom_recht`) anzeigen.\n\n[Zurück nach oben](#ue_2)\n\n\n### Übung 3 {#data3}\n\n-   Verwenden Sie weiterhin den Datensatz aus Übung 1 & 2.\n-   Lassen Sie sich nur Hochschulen anzeigen, die 1971, 1457 oder 1995 gegründet wurden - und für diese Fälle nur den Namen und das Gründungsjahr.\n-   Sortieren Sie den Datensatz entsprechend dieser Reihenfolge. (Legen Sie dazu eine `factor`-Variable an, welche die entsprechende Reihenfolge festlegt.)\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Aachen\",\"FH Bonn-Rhein-Sieg\")\n```\n:::\n\n\n[Zurück nach oben](#ue_3)\n\n\n\n### Übung 4 {#data4}\n\n-   Erstellen Sie in Ihrem Verzeichnis für diesen Kurs ein [R-Projekt](#rproj)\n-   Legen Sie die Erwerbstätigenbefragung in Ihrem Verzeichnis im Unterordner *data* ab.\n-   Lesen Sie den Datensatz `BIBBBAuA_2018_small.csv` [wie oben gezeigt](#import) in R ein und legen Sie den Datensatz unter dem Objektnamen `etb_small` ab.\n-   Nutzen Sie `head()` und `View()`, um sich einen Überblick über den Datensatz zu verschaffen.\n-   Wie viele Befragte (Zeilen) enthält der Datensatz?\n-   Lassen Sie sich die Variablennamen von `etb_small` mit `names()` anzeigen!\n-   Wie können Sie sich die Zeile anzeigen lassen, welche den/die Befragte\\*n mit der `intnr` 2781 enthält?\n-   Wie alt ist der/die Befragte mit der `intnr` 2781?\n-   Erstellen Sie eine neue Variable mit dem Alter der Befragten im Jahr 2022! (Das Geburtsjahr ist in der Variable `S2_j` abgelegt.)\n-   Wählen Sie alle Befragten aus, die nach 1960 geboren wurden legen Sie diese Auswahl unter `nach_1960` ab.\n-   Wie viele Spalten hat `nach_1960`? Wie viele Zeilen?\n\n[Zurück nach oben](#ue_4)\n\n## Anhang\n\n### Alternativen zu R-Projekten {#setwd}\n\nNeben dem Einrichten eines Projekts können wir den Pfad auch mit `setwd()` setzen oder direkt in `read.table()` angeben. Das hat allerdings den Nachteil, dass diese Strategie nicht auf andere Rechner übertragbar ist: wenn jemand anderes die `.Rproj`-Datei öffnet, wird R automatisch die Pfade relativ zum Speicherort der Datei setzen. Das gilt auch wenn wir das Verzeichnis verschieben auf unserem Gerät - R wird automatisch das Arbeitsverzeichnis auf den neuen Speicherort setzen.\n\nZum Setzen des Arbeitsverzeichnis mit `setwd()` setzen wir in die Klammern den Pfad des Ordners ein. Wichtig dabei ist dass Sie ggf. alle `\\` durch `/`ersetzen müssen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"D:/Kurse/R_BIBB\")\n```\n:::\n\n\nMit `getwd()` lässt sich überprüfen, ob das funktioniert hat:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n:::\n\n\nHier sollte der mit `setwd()` gesetzte Pfad erscheinen.\n\nAlternativ können wir auch in `read.table()` den vollen Pfad angeben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\netb <- read.table(\"C:/Kurse/R_BIBB/data/BIBBBAuA_2018_small.csv\", sep = \";\", header = T, stringsAsFactors = F)\n```\n:::\n\n\n### Zeilen & Spaltenauswahl ohne `{dplyr}` {#selfiltbase}\n\nNatürlich kann auch base R (also R ohne Erweiterungen wie `{dplyr}` Datensätze filtern usw.), dazu wird  \\[ \\] verwendet:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[1,1] # erste Zeile, erste Spalte\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173\n```\n:::\n\n```{.r .cell-code}\ndat1[1,]  # erste Zeile, alle Spalten\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof        uni more10k    uni_fct\n1 19173   322 1971 59.54348 Uni Bremen    TRUE Uni Bremen\n```\n:::\n\n```{.r .cell-code}\ndat1[,1]  # alle Zeilen, erste Spalte (entspricht hier dat1$studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173  5333 15643\n```\n:::\n\n```{.r .cell-code}\ndat1[,\"studs\"] # alle Zeilen, Spalte mit Namen studs -> achtung: \"\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173  5333 15643\n```\n:::\n:::\n\n\nNatürlich können wir auch mehrere Zeilen oder Spalten auswählen. Dafür müssen wir wieder auf `c( )` zurückgreifen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[c(1,2),]  ## 1. & 2. Zeile, alle Spalten\ndat1[,c(1,3)]  ## alle Zeilen, 1. & 3. Spalte (entspricht dat1$studs & dat1$stu_prof)\ndat1[,c(\"studs\",\"uni\")] ## alle Zeilen, Spalten mit Namen studs und uni\n```\n:::\n\n\nIn diese eckigen Klammern können wir auch Bedingungen schreiben, um so Auswahlen aus `dat1` zu treffen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 # vollständiger Datensatz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1[dat1$uni == \"Uni Oldenburg\", ] # Zeilen in denen uni gleich \"Uni Oldenburg\", alle Spalten\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni more10k       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1$studs[dat1$uni == \"Uni Oldenburg\" ] # Nur Studi-Zahl nachsehen: kein Komma \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15643\n```\n:::\n:::\n\n\nDas funktioniert soweit wie gewünscht und wir können das Ganze jetzt erweitern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[dat1$uni == \"Uni Oldenburg\" & dat1$studs > 10000, ] # & bedeutet UND\n```\n:::\n\n\nWir können auch hier einen ODER-Operator verwenden:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[dat1$uni == \"Uni Oldenburg\" | dat1$studs > 10000, ]\n```\n:::\n\n\n\n### `select()` vs `$`\n\n \nWenn wir mit `select()` eine spezifische Variable auswählen, wird trotzdem die Datenstruktur als `data.frame()` erhalten, während die Auswahl `dat1$variablenname` die Spalte als Vektor (also Wertereihe) ausgibt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$studs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173  5333 15643\n```\n:::\n\n```{.r .cell-code}\nclass(dat1$studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ndat1$studs/ 20\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 958.65 266.65 782.15\n```\n:::\n:::\n\n\n`select()` erhält die Werte als Spalte eines `data.frame`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% select(studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs\n1 19173\n2  5333\n3 15643\n```\n:::\n\n```{.r .cell-code}\ndat1 %>% select(studs) %>% class()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\ndat1 %>% select(studs)/20 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   studs\n1 958.65\n2 266.65\n3 782.15\n```\n:::\n:::\n",
    "supporting": [
      "02_intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}